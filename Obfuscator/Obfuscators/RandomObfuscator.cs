using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Obfuscator.Obfuscators
{
    /// <remarks>
    /// The random obfuscator only works when dealing with entire classes.
    /// When processing files containing methods which are not encapsulated by a class, the obfuscator will not provide valid results.
    /// </remarks>
    public class RandomObfuscator : CSharpSyntaxRewriter
    {
        private readonly SemanticModel SemanticModel;
        private static Random random = new();
        private const string Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        /// <summary>
        /// Contains all processed property names.
        /// Key = old property name. Value = new property name.
        /// </summary>
        private readonly Dictionary<string, string> properties = new();

        /// <summary>
        /// Contains all processed field names.
        /// Key = old field name. Value = new field name.
        /// </summary>
        private readonly Dictionary<string, string> fields = new();

        /// <summary>
        /// Contains all processed parameter names of the method that is currently being processed.
        /// Key = old name. Value = new name.
        /// </summary>
        private readonly Dictionary<string, string> methodParameters = new();

        /// <summary>
        /// Contains all processed local variable names of the method that is currently being processed.
        /// Key = old name. Value = new name.
        /// </summary>
        private readonly Dictionary<string, string> methodLocals = new();

        public RandomObfuscator(SemanticModel semanticModel)
        {
            this.SemanticModel = semanticModel;

            // TODO make it possible to enable/disable diagnostics
            //var diagnosticErrors = semanticModel.GetDiagnostics().Where(a => a.Severity == DiagnosticSeverity.Error);
            //Console.WriteLine("Errors: " + diagnosticErrors.Count());
            //foreach (var diagnosticError in diagnosticErrors)
            //{
            //    Console.WriteLine(diagnosticError + "\n\n");
            //}
        }

        public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            var renamedParameters = RenameMethodParameters(node);
            var renamedStatements = RenameStatements(node);

            var newMethodDeclaration = node.WithParameterList(renamedParameters.ParameterList).WithBody(node.Body.WithStatements(renamedStatements.Body.Statements));

            // After processing the method, we need to clear the dictionaries containing the method variables.
            this.methodParameters.Clear();
            this.methodLocals.Clear();

            return newMethodDeclaration;
        }

        private MethodDeclarationSyntax RenameMethodParameters(MethodDeclarationSyntax node)
        {
            MethodDeclarationSyntax newMethodDeclaration = node;
            ParameterListSyntax newParameterList = node.ParameterList;
            for (var i = 0; i < node.ParameterList.Parameters.Count; i++)
            {
                var parameterType = node.ParameterList.Parameters[i].Type;
                var newParameterName = GetRandomVariableName();
                var newParameter = node.ParameterList.Parameters[i].
                    WithIdentifier(
                        Identifier(newParameterName).
                        WithTriviaFrom(node.ParameterList.Parameters[i].Identifier)
                    )
                    .WithType(ParseTypeName(parameterType.ToFullString()));

                newParameterList = newParameterList.ReplaceNode(newParameterList.Parameters[i], newParameter);

                this.methodParameters.Add(node.ParameterList.Parameters[i].Identifier.Text, newParameterName);
            }

            return newMethodDeclaration.WithParameterList(newParameterList);
        }

        private MethodDeclarationSyntax RenameStatements(MethodDeclarationSyntax node)
        {
            MethodDeclarationSyntax newMethodDeclaration = node;

            var newStatements = new SyntaxList<StatementSyntax>();
            foreach (var statement in node.Body.Statements)
            {
                newStatements = newStatements.Add(RenameStatement(statement));
            }

            return newMethodDeclaration.WithBody(node.Body.WithStatements(newStatements));
        }

        private StatementSyntax RenameStatement(StatementSyntax statement)
        {
            var newStatement = statement;
            var identifierTokens = statement.DescendantTokens().Where(a => a.IsKind(SyntaxKind.IdentifierToken));
            Dictionary<SyntaxToken, SyntaxToken> oldAndNewIdentifiers = new();

            foreach (var identifierToken in identifierTokens)
            {
                var propertiesName = properties.Where(a => a.Key == identifierToken.Text).FirstOrDefault();
                var fieldsName = fields.Where(a => a.Key == identifierToken.Text).FirstOrDefault();
                var parametersName = methodParameters.Where(a => a.Key == identifierToken.Text).FirstOrDefault();
                var localsName = methodLocals.Where(a => a.Key == identifierToken.Text).FirstOrDefault();

                if (!propertiesName.Equals(default(KeyValuePair<string, string>)))
                {
                    oldAndNewIdentifiers.Add(identifierToken, Identifier(propertiesName.Value).WithTriviaFrom(identifierToken));
                }
                else if (!fieldsName.Equals(default(KeyValuePair<string, string>)))
                {
                    oldAndNewIdentifiers.Add(identifierToken, Identifier(fieldsName.Value).WithTriviaFrom(identifierToken));
                }
                else if (!parametersName.Equals(default(KeyValuePair<string, string>)))
                {
                    oldAndNewIdentifiers.Add(identifierToken, Identifier(parametersName.Value).WithTriviaFrom(identifierToken));
                }
                else if (!localsName.Equals(default(KeyValuePair<string, string>)))
                {
                    oldAndNewIdentifiers.Add(identifierToken, Identifier(localsName.Value).WithTriviaFrom(identifierToken));
                }
                else if (identifierTokens.Count() != oldAndNewIdentifiers.Count)
                {
                    if (SkipRenameIdentifier(identifierToken))
                    {
                        continue;
                    }

                    var newName = GetRandomVariableName();

                    oldAndNewIdentifiers.Add(identifierToken, Identifier(newName).WithTriviaFrom(identifierToken));
                    this.methodLocals.Add(identifierToken.Text, newName);
                }
            }

            return newStatement.ReplaceTokens(oldAndNewIdentifiers.Keys, (oldToken, _) => oldAndNewIdentifiers[oldToken]);
        }

        public override SyntaxNode? VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            // Change property name
            var newName = GetRandomVariableName();
            var newIdentifier = Identifier(newName).WithTriviaFrom(node.Identifier);
            this.properties.Add(node.Identifier.Text, newName);

            // Change getter and setter identities (if any)
            Dictionary<SyntaxToken, SyntaxToken> oldAndNewIdentifiers = new();
            for (int i = 0; i < node?.AccessorList?.Accessors.Count; i++)
            {
                for (int j = 0; j < node?.AccessorList.Accessors[i]?.Body?.Statements.Count; j++)
                {
                    var identifierTokens = node?.AccessorList?.Accessors[i]?.Body?.Statements[j].DescendantTokens().Where(a => a.IsKind(SyntaxKind.IdentifierToken));
                    foreach (var identifierToken in identifierTokens)
                    {
                        var fieldsName = fields.Where(a => a.Key == identifierToken.Text).FirstOrDefault();
                        if (!fieldsName.Equals(default(KeyValuePair<string, string>)))
                        {
                            oldAndNewIdentifiers.Add(identifierToken, Identifier(fieldsName.Value).WithTriviaFrom(identifierToken));
                        }
                    }
                }
            }

            return node.ReplaceTokens(oldAndNewIdentifiers.Keys, (oldToken, _) => oldAndNewIdentifiers[oldToken]).WithIdentifier(newIdentifier);
        }

        public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
        {
            SeparatedSyntaxList<VariableDeclaratorSyntax> variables = node.Variables;

            for (var i = 0; i < node.Variables.Count; i++)
            {
                //var symbols = this.SemanticModel.LookupSymbols(node.Variables[i].SpanStart);
                //var accessibility = symbols[i].DeclaredAccessibility; //Get private/public/etc

                var newName = GetRandomVariableName();

                var newIdentifier = Identifier(newName);

                if (node.Variables[i].Initializer != null)
                {
                    newIdentifier = newIdentifier.WithTriviaFrom(node.Variables[i].Identifier);
                }

                variables = variables.Replace(variables.ElementAt(i), variables.ElementAt(i).WithIdentifier(newIdentifier));

                this.fields.Add(node.Variables[i].Identifier.Text, newName);
            }

            return node.WithVariables(variables);
        }

        private bool SkipRenameIdentifier(SyntaxToken identifierToken)
        {
            // Do not change identifiers for generic names, like List<int>
            if (identifierToken.Parent.IsKind(SyntaxKind.GenericName))
            {
                return true;
            }

            // Do not change identifiers with names like var and SqlCommand
            if (identifierToken.Parent.Parent.IsKind(SyntaxKind.VariableDeclaration)
                && identifierToken.Parent.Parent.DescendantNodes().FirstOrDefault().IsKind(SyntaxKind.IdentifierName)
                && identifierToken.Parent.Parent.DescendantNodes().FirstOrDefault().Equals(identifierToken.Parent))
            {
                return true;
            }

            // Do not change identifiers which represent a method call, or identifiers which represent a property access of an object.
            if (identifierToken.GetPreviousToken().IsKind(SyntaxKind.DotToken))
            {
                return true;
            }

            // Do not change identifiers which represent the creation of a new object
            if (identifierToken.GetPreviousToken().IsKind(SyntaxKind.NewKeyword))
            {
                return true;
            }

            // Skip identifiers representing classes and types. e.g. var and Console
            if (this.SemanticModel.GetTypeInfo(identifierToken.Parent).Type != null)
            {
                return true;
            }

            // The last check does not work for NLog in our case, so we check for it specifically
            // This is commonly used in the C# Juliet Test Suite 1.3 and therefore needed in our project
            if (identifierToken.Text == "NLog")
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Generate a random and unique variable name.
        /// </summary>
        /// <returns>Random variable name of length 10.</returns>
        private string GetRandomVariableName()
        {
            var count = 10;
            string name;

            do
            {
                name = string.Empty;
                for (var i = 0; i < count; i++)
                {
                    int character = random.Next(Alphabet.Length);
                    name += Alphabet.ElementAt(character).ToString();
                }
            } while (
                this.properties.ContainsValue(name)
                || this.fields.ContainsValue(name)
                || this.methodParameters.ContainsValue(name)
                || this.methodLocals.ContainsValue(name));

            return name;
        }
    }
}
