using Extractor.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Data.SqlClient;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Extractor.Rewriters
{
    public class JulietRewriter : CSharpSyntaxRewriter
    {
        private readonly bool clean = true;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="clean">
        /// Indicates whether or not the test cases should be cleaned.
        /// When cleaned, the substrings 'good' or 'bad' are removed from variable names (to remove any obvious clues for the classifiers).
        /// Additionally, method calls to the Juliet Test Suite IO class are replaced by .Net default methods.
        /// </param>
        public JulietRewriter(bool clean)
        {
            this.clean = clean;
        }

        public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)
        {
            // Filter Main and 'obvious' RunTest methods
            if (!node.Identifier.Text.ToLower().StartsWith("bad") && !node.Identifier.Text.ToLower().StartsWith("good"))
            {
                return null;
            }

            // Filter 'caller' methods not related to a vulnerability
            if (node.Identifier.Text.ToLower() == "good")
            {
                return null;
            }

            var renamedStatements = node.Body.Statements;

            if (clean)
            {
                renamedStatements = RenameStatements(node).Body.Statements;
            }

            var newMethodName = "Good";
            if (node.Identifier.Text.ToLower().Contains("bad"))
            {
                newMethodName = "Bad";
            }

            return node.WithIdentifier(Identifier(newMethodName).WithTriviaFrom(node.Identifier))
                .WithBody(node.Body.WithStatements(renamedStatements));
        }

        private static MethodDeclarationSyntax RenameStatements(MethodDeclarationSyntax node)
        {
            MethodDeclarationSyntax newMethodDeclaration = node;

            var newStatements = new SyntaxList<StatementSyntax>();
            foreach (var statement in node.Body.Statements)
            {
                var statementWithoutFlawIndicators = RenameFlawIndicators(statement);
                var statementWithoutIOMethods = RenameIOMethods(statementWithoutFlawIndicators);

                newStatements = newStatements.Add(statementWithoutIOMethods);
            }

            return newMethodDeclaration.WithBody(node.Body.WithStatements(newStatements));
        }

        /// <summary>
        /// Removes 'bad' and/or 'good' from variable names, which could indicate whether or not a method is vulnerable.
        /// </summary>
        /// <remarks>
        /// For example, we want to remove 'bad' from 'badSqlCommand' to become 'sqlCommand'.
        /// </remarks>
        private static StatementSyntax RenameFlawIndicators(StatementSyntax statement)
        {
            var newStatement = statement;
            var identifierTokens = statement.DescendantTokens().Where(a => a.IsKind(SyntaxKind.IdentifierToken));
            Dictionary<SyntaxToken, SyntaxToken> oldAndNewIdentifiers = new();

            foreach (var identifierToken in identifierTokens)
            {
                if (identifierToken.Text.StartsWith("bad") || identifierToken.Text.StartsWith("good"))
                {
                    var newName = identifierToken.Text.Replace("good", string.Empty)
                        .Replace("bad", string.Empty)
                        .FirstCharToLowerCase();
                    oldAndNewIdentifiers.Add(identifierToken, Identifier(newName).WithTriviaFrom(identifierToken));
                }
            }

            return newStatement.ReplaceTokens(oldAndNewIdentifiers.Keys, (oldToken, _) => oldAndNewIdentifiers[oldToken]);
        }

        /// <summary>
        /// Remove/rename methods which are called from the Juliet Test Suite IO class.
        /// For example, IO.GetDBConnection(), IO.Writeline() and IO.Logger.Log() will be renamed to their .Net equivalent.
        /// </summary>
        private static StatementSyntax RenameIOMethods(StatementSyntax statement)
        {
            var newStatement = ReplaceDbConnection(statement);
            newStatement = ReplaceWriteLine(newStatement);
            newStatement = ReplaceLogging(newStatement);

            return newStatement;
        }

        private static StatementSyntax ReplaceDbConnection(StatementSyntax statement)
        {
            var getDBConnectionNode = statement.DescendantNodes()
                .Where(a => a.IsKind(SyntaxKind.VariableDeclarator) && a.GetText().ToString().ToLower() == "dbconnection = io.getdbconnection()")
                .FirstOrDefault();
            
            if (getDBConnectionNode == null)
            {
                return statement;
            }

            var dbConnectionInvocation = getDBConnectionNode.ChildNodes().First().ChildNodes().First();

            var argsList = new SeparatedSyntaxList<ArgumentSyntax>();
            argsList = argsList.Add(
                Argument(
                    LiteralExpression(
                        SyntaxKind.StringLiteralExpression,
                        Literal("server=localhost;uid=mysql_user;password=mysql_password;database=dbname")
                    )
                )
            );

            var defaultDbConnection = ObjectCreationExpression(ParseTypeName(nameof(SqlConnection)), ArgumentList(argsList), null).NormalizeWhitespace();
            return statement.ReplaceNode(dbConnectionInvocation, defaultDbConnection);
        }

        private static StatementSyntax ReplaceWriteLine(StatementSyntax statement)
        {
            Dictionary<SyntaxToken, SyntaxToken> oldAndNewIdentifiers = new();

            var expressionStatementNodes = statement.DescendantNodes()
                .Where(a => a.IsKind(SyntaxKind.ExpressionStatement)
                    && a.GetFirstToken().Text == "IO");

            foreach (var expressionStatementNode in expressionStatementNodes)
            {
                var simpleMemberAccessNode = expressionStatementNode.DescendantNodes().First(a => a.IsKind(SyntaxKind.SimpleMemberAccessExpression));
                var identifierNodes = simpleMemberAccessNode.ChildNodes().Where(a => a.IsKind(SyntaxKind.IdentifierName));

                foreach (var identifierNode in identifierNodes)
                {
                    SyntaxToken identifierToken = identifierNode.GetFirstToken().IsKind(SyntaxKind.IdentifierToken)
                        ? identifierNode.GetFirstToken() : default;
                    if (identifierToken != default && identifierToken.Text == "IO")
                    {
                        var newName = identifierToken.Text.Replace("IO", "Console");
                        oldAndNewIdentifiers.Add(identifierToken, Identifier(newName).WithTriviaFrom(identifierToken));
                    }
                }
            }
            return statement.ReplaceTokens(oldAndNewIdentifiers.Keys, (oldToken, _) => oldAndNewIdentifiers[oldToken]);
        }

        private static StatementSyntax ReplaceLogging(StatementSyntax statement)
        {
            Dictionary<SyntaxNode, SyntaxNode> oldAndNewExpressionStatements = new();

            var expressionStatementNodes = statement.DescendantNodes()
                .Where(a => a.IsKind(SyntaxKind.ExpressionStatement)
                    && a.GetFirstToken().Text == "IO");

            foreach (var expressionStatementNode in expressionStatementNodes)
            {
                if (!expressionStatementNode.ToString().StartsWith("IO.Logger.Log"))
                {
                    continue;
                }

                var simpleMemberAccessNode = expressionStatementNode.DescendantNodes()
                    .First(a => a.IsKind(SyntaxKind.SimpleMemberAccessExpression));

                var exceptionArgument = simpleMemberAccessNode.Parent.ChildNodes()
                    .Single(a => a.IsKind(SyntaxKind.ArgumentList)).ChildNodes()
                    .Where(a => a.ChildNodes().First().IsKind(SyntaxKind.IdentifierName)).First();

                var consoleWriteLineException = ExpressionStatement(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName("Console"),
                            IdentifierName("Writeline")))
                    .WithArgumentList(
                        ArgumentList(
                            SingletonSeparatedList<ArgumentSyntax>(
                                Argument(
                                    IdentifierName(exceptionArgument.ToString()))))))
                    .WithTriviaFrom(expressionStatementNode);

                oldAndNewExpressionStatements.Add(expressionStatementNode, consoleWriteLineException);
            }
            return statement.ReplaceNodes(oldAndNewExpressionStatements.Keys, (oldNode, _) => oldAndNewExpressionStatements[oldNode]);
        }
    }
}
