using Extractor.Configurations;
using Extractor.Entities;
using Extractor.Rewriters;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text.RegularExpressions;

namespace Extractor.Extractors
{
    public class JulietExtractor : Extractor
    {
        private readonly string[] AcceptedFlowVariants;
        private readonly JulietConfiguration config;
        private readonly string[] cwes;
        private readonly List<DataSetStatistics> statistics = new();

        public JulietExtractor(JulietConfiguration config)
        {
            this.config = config;
            this.AcceptedFlowVariants = config.AcceptedFlowVariants.Split(';');
            this.cwes = config.CWEs.Split(';');
            InitStatistics();
            CreateOutputCweDirectories(this.cwes, config.OutputLocation);
        }

        public override void ExtractCases()
        {
            string path = config.JulietLocation;
            string[] files;
            if (Directory.Exists(path))
            {
                files = Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories);
            }
            else
            {
                files = new string[] { path };
            }

            foreach (var file in files)
            {
                if (this.SkipFile(file))
                {
                    continue;
                }

                ExtractSingleFile(file);
            }

            SaveStatistics(this.config.OutputLocation, "Juliet_Statistics.txt", this.statistics);
        }

        protected override SyntaxNode GetLabeledSyntaxNode(string filePath, bool isVulnerable)
        {
            // isVulnerable is unused in the JulietExtractor
            string fileText = File.ReadAllText(filePath);
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(fileText).WithFilePath(filePath);

            var julietRewriter = new JulietRewriter(config.Clean);
            return julietRewriter.Visit(syntaxTree.GetRoot());
        }

        private void ExtractSingleFile(string filename)
        {
            var labeledSampleTree = this.GetLabeledSyntaxNode(filename, true);
            var cwe = GetCweFromPath(filename);
            SaveSample(labeledSampleTree, cwe, this.config.OutputLocation, filename);

            var methods = labeledSampleTree.DescendantNodes().Where(a => a.IsKind(SyntaxKind.MethodDeclaration));
            var numberOfSamples = methods.Count();
            var numberOfBadSamples = methods.Where(a => ((MethodDeclarationSyntax)a).Identifier.Text == "Bad").Count();
            var numberOfGoodSamples = methods.Where(a => ((MethodDeclarationSyntax)a).Identifier.Text == "Good").Count();

            this.statistics.Single(a => a.Cwe == cwe).TotalSamples += numberOfSamples;
            this.statistics.Single(a => a.Cwe == cwe).VulnerableSamples += numberOfBadSamples;
            this.statistics.Single(a => a.Cwe == cwe).SafeSamples += numberOfGoodSamples;
        }

        /// <summary>
        /// Get a bool which indicates whether or not to skip this file.
        /// Files with specific flow variants will be skipped (as described in Juliet Test Suite v1.2 for Java - User Guide - Appendix C).
        /// Only files which contain vulnerabilities in a single method are used in this project.
        /// </summary>
        private bool SkipFile(string file)
        {
            var lastPartofFileName = Path.GetFileName(file).Split("_").Last();
            var flowVariant = Regex.Match(lastPartofFileName, @"(\d+)").Value;

            if (string.IsNullOrWhiteSpace(flowVariant))
            {
                return true;
            }

            if (!AcceptedFlowVariants.Contains(flowVariant))
            {
                return true;
            }

            if (!cwes.Contains(GetCweFromPath(file)))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Create an entry in the statistics collection for each cwe category.
        /// </summary>
        private void InitStatistics()
        {
            foreach (var cwe in this.cwes)
            {
                statistics.Add(new DataSetStatistics(cwe));
            }
        }

        private static string GetCweFromPath(string path) => Regex.Match(path, "CWE[0-9]{1,5}").Value;
    }
}
