using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using System.Text.RegularExpressions;
using DataSetSplitter.Configurations;
using Extractor.Entities;
using DataSetSplitter.Entities;

namespace DataSetSplitter
{
    /// <summary>
    /// Collects all methods/samples and subsequently splits them in single files, seperated over a training, test, and validation directory.
    /// </summary>
    public class Splitter
    {
        private const string Training = "Training";
        private const string Validation = "Validation";
        private const string Test = "Test";

        private readonly DataSetSplitterConfiguration config;
        private readonly HashSet<string> cwes = new();
        private readonly List<DataSetStatistics> statistics = new();
        private readonly List<SampleContainer> samples = new();
        private static Random random = new ();

        public Splitter(DataSetSplitterConfiguration config)
        {
            this.config = config;
        }

        public void ExtractCases()
        {
            string path = config.SamplesLocation;
            string[] files;
            if (Directory.Exists(path))
            {
                files = Directory.GetFiles(path, "*.cs", SearchOption.AllDirectories);
            }
            else
            {
                files = new string[] { path };
            }

            foreach (var file in files)
            {
                ExtractSingleFile(file);
            }

            this.InitStatistics();
            this.CreateDataSetDirectories(config.OutputLocation);
            this.SaveSamples();
            SaveStatistics(this.config.OutputLocation, "Split_Statistics.txt", this.statistics);
        }

        private void ExtractSingleFile(string filename)
        {
            var cwe = GetCweFromPath(filename);
            this.cwes.Add(cwe);

            var samples = GetSampleSyntaxNodes(filename, cwe);

            for(int i = 0; i < samples.Count(); i++)
            {
                var sample = samples.ElementAt(i);
                var method = sample.DescendantNodes().Single(a => a.IsKind(SyntaxKind.MethodDeclaration)) as MethodDeclarationSyntax;
                this.samples.Add(new SampleContainer(sample, filename.Replace(".cs", "_" + i + "_" + method.Identifier.Text +".cs"), cwe, method.Identifier.Text == "Bad"));
            }
        }

        private IEnumerable<SyntaxNode> GetSampleSyntaxNodes(string filePath, string cwe)
        {
            string fileText = File.ReadAllText(filePath);
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(fileText).WithFilePath(filePath);
            var methods = syntaxTree.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>();
            var classes = new List<SyntaxNode>();
            var treeWithoutMethods = syntaxTree.GetRoot().RemoveNodes(methods, SyntaxRemoveOptions.KeepNoTrivia);

            if (treeWithoutMethods == null)
            {
                throw new ArgumentNullException("Unexpected problems occured while removing all methods from the syntax tree.");
            }

            foreach (var method in methods)
            {
                var classDeclaration = treeWithoutMethods.DescendantNodes().FirstOrDefault(a => a.IsKind(SyntaxKind.ClassDeclaration)) as ClassDeclarationSyntax;

                if (classDeclaration == null)
                {
                    throw new ArgumentNullException("Unexpected problems occured while adding the method to the class.");
                }

                var newClassDecleration = classDeclaration.AddMembers(method);

                classes.Add(
                    treeWithoutMethods.ReplaceNode(classDeclaration, newClassDecleration)
                );
            }

            return classes;
        }

        /// <summary>
        /// Create an entry in the statistics collection for each cwe category.
        /// </summary>
        private void InitStatistics()
        {
            foreach (var cwe in this.cwes)
            {
                statistics.Add(new DataSetStatistics(cwe));
            }
        }

        private static string GetCweFromPath(string path) => Regex.Match(path, "CWE[0-9]{1,5}").Value;

        private void CreateDataSetDirectories(string outputLocation)
        {
            foreach(var cwe in this.cwes)
            {
                Directory.CreateDirectory(Path.GetFullPath(Path.Join(outputLocation, Training, "Good", cwe)));
                Directory.CreateDirectory(Path.GetFullPath(Path.Join(outputLocation, Training, "Bad", cwe)));
                Directory.CreateDirectory(Path.GetFullPath(Path.Join(outputLocation, Validation, "Good", cwe)));
                Directory.CreateDirectory(Path.GetFullPath(Path.Join(outputLocation, Validation, "Bad", cwe)));
                Directory.CreateDirectory(Path.GetFullPath(Path.Join(outputLocation, Test, "Good", cwe)));
                Directory.CreateDirectory(Path.GetFullPath(Path.Join(outputLocation, Test, "Bad", cwe)));
            }
        }

        private void SaveSamples()
        {
            foreach(var sample in this.samples)
            {
                var percentage = random.Next(100);
                if (percentage < 80)
                {
                    SaveSampleAndUpdateStatistics(sample, Training);
                    continue;
                }

                if (percentage < 90)
                {
                    SaveSampleAndUpdateStatistics(sample, Validation);
                    continue;
                }

                SaveSampleAndUpdateStatistics(sample, Test);
            }
        }

        private void SaveSampleAndUpdateStatistics(SampleContainer sample, string splitDirectory)
        {
            var goodOrBad = string.Empty;

            this.statistics.Single(a => a.Cwe == sample.CWE).TotalSamples++;

            if (sample.fileName.Contains("_Bad.cs"))
            {
                goodOrBad = "Bad";

                this.statistics.Single(a => a.Cwe == sample.CWE).VulnerableSamples++;

                switch (splitDirectory)
                {
                    case Training:
                        this.statistics.Single(a => a.Cwe == sample.CWE).VulnerableSamplesTraining++;
                        break;
                    case Validation:
                        this.statistics.Single(a => a.Cwe == sample.CWE).VulnerableSamplesValidation++;
                        break;
                    case Test:
                        this.statistics.Single(a => a.Cwe == sample.CWE).VulnerableSamplesTest++;
                        break;
                }
            }

            if (sample.fileName.Contains("_Good.cs"))
            {
                goodOrBad = "Good";

                this.statistics.Single(a => a.Cwe == sample.CWE).SafeSamples++;

                switch (splitDirectory)
                {
                    case Training:
                        this.statistics.Single(a => a.Cwe == sample.CWE).SafeSamplesTraining++;
                        break;
                    case Validation:
                        this.statistics.Single(a => a.Cwe == sample.CWE).SafeSamplesValidation++;
                        break;
                    case Test:
                        this.statistics.Single(a => a.Cwe == sample.CWE).SafeSamplesTest++;
                        break;
                }
            }

            File.WriteAllText(Path.Combine(this.config.OutputLocation, splitDirectory, goodOrBad, sample.CWE, Path.GetFileName(sample.fileName)), sample.sampleTree.ToFullString());
        }

        private static void SaveStatistics(string outputLocation, string outputFileName, IList<DataSetStatistics> statistics)
        {
            foreach (var statistic in statistics)
            {
                if (statistic.TotalSamples == 0)
                {
                    statistics.Remove(statistic);
                }
            }

            File.WriteAllText(Path.Combine(outputLocation, outputFileName), string.Join("\n", statistics));
        }
    }
}
